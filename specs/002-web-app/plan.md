# Implementation Plan: Phase II Full-Stack Web Application

**Branch**: `002-web-app` | **Date**: 2025-12-13 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/002-web-app/spec.md`

**Note**: This plan was generated by the `/sp.plan` command following spec-driven development workflow.

## Summary

Phase II transitions the Todo CRUD application from a console-based CLI (Phase I) to a full-stack web application with persistence, authentication, and multi-user support. The implementation uses Next.js 15 for the frontend, FastAPI for the backend API, and Neon PostgreSQL for data persistence. The architecture maintains clear separation between frontend and backend as a modular monolith, preparing for future microservices decomposition in Phase IV.

**Primary Requirement**: Build a web-based todo application where authenticated users can create, read, update, delete, and complete tasks with all data persisted to a PostgreSQL database. Each user's tasks are isolated from other users.

**Technical Approach**: Separate frontend and backend codebases deployed independently (Vercel for frontend, cloud hosting for backend), communicating via RESTful API with JWT-based authentication. Database-first design with Alembic migrations managing schema evolution.

## Technical Context

**Language/Version**:
- Frontend: TypeScript 5.x (with Next.js 15, React 18)
- Backend: Python 3.13+ (same as Phase I for consistency)

**Primary Dependencies**:
- Frontend: Next.js 15.x, React 18.x, TypeScript 5.x, Tailwind CSS 3.x, shadcn/ui, axios/fetch
- Backend: FastAPI 0.100+, SQLAlchemy 2.x, Alembic, Pydantic 2.x, python-jose (JWT), passlib (bcrypt), uvicorn
- Database: PostgreSQL 14+ via Neon (serverless)
- Auth: Better Auth or custom JWT implementation

**Storage**:
- PostgreSQL 14+ (Neon serverless platform)
- Schema managed via Alembic migrations
- Connection pooling via SQLAlchemy async engine

**Testing**:
- Backend: pytest, pytest-asyncio, httpx (for FastAPI testing)
- Frontend: Jest, React Testing Library, Playwright (E2E)
- Manual testing for Phase II (automated in future phases)

**Target Platform**:
- Frontend: Web browsers (Chrome 90+, Firefox 88+, Safari 14+, Edge 90+), deployed to Vercel
- Backend: Linux server (containerized Python 3.13+), deployed to Railway/Render/Fly.io
- Database: Neon PostgreSQL cloud (serverless)

**Project Type**: Web application (frontend + backend separation)

**Performance Goals**:
- API response time: P95 < 500ms
- Page load time: < 3 seconds (initial load)
- Task list rendering: < 2 seconds for up to 10,000 tasks per user
- Concurrent users: Minimum 100 without degradation
- Database query time: < 1 second per query

**Constraints**:
- Backend must use Python 3.13+ stdlib + approved dependencies only (no arbitrary packages)
- Frontend must use Next.js 15 (not other React frameworks)
- Database must be PostgreSQL (not SQLite, MongoDB, or file-based)
- Must use Better Auth or custom JWT (no third-party OAuth in Phase II)
- HTTPS required for production (TLS/SSL)
- CORS restricted to frontend domain only (no wildcard)
- Password hashing with bcrypt (no plain text storage)
- Free tier hosting only (Neon free, Vercel free, backend free tier)

**Scale/Scope**:
- Expected users: 100-1,000 initial users
- Tasks per user: Up to 10,000 tasks
- API endpoints: ~10-15 endpoints (auth + CRUD)
- Frontend pages: 4-5 pages (login, register, dashboard, task detail)
- Frontend components: 15-20 reusable components

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

### Phase II Constitutional Requirements

✅ **Technology Stack Compliance**:
- Frontend: Next.js 15 ✅ (matches constitution requirement)
- Backend: FastAPI ✅ (matches constitution requirement)
- Database: Neon PostgreSQL ✅ (matches constitution requirement)
- Auth: Better Auth/JWT ✅ (matches constitution requirement)

✅ **Architecture Compliance**:
- Modular Monolith: Frontend/backend separation ✅
- Clear module boundaries: API layer, data layer, presentation layer ✅
- No Phase III technologies: No AI Agents, no MCP ✅
- Backward compatibility: Phase I CLI preserved in src/main.py ✅

✅ **Deployment Compliance**:
- Frontend deployment: Vercel ✅
- Backend deployment: Cloud provider (Railway/Render/Fly.io) ✅
- Database: Neon (serverless PostgreSQL) ✅

✅ **Migration Path Compliance**:
- Extract TaskManager logic → FastAPI endpoints ✅ (planned)
- Build Next.js UI consuming API ✅ (planned)
- No breaking changes to Phase I ✅ (Phase I code frozen)

### Gate Results

**Status**: ✅ **ALL GATES PASSED**

No constitutional violations. All technology choices align with Phase II requirements. No complexity justifications needed.

## Project Structure

### Documentation (this feature)

```text
specs/002-web-app/
├── plan.md              # This file (/sp.plan command output)
├── research.md          # Phase 0 output (/sp.plan command) - technology decisions
├── data-model.md        # Phase 1 output (/sp.plan command) - database schema
├── quickstart.md        # Phase 1 output (/sp.plan command) - local setup guide
├── contracts/           # Phase 1 output (/sp.plan command)
│   └── api-spec.yaml    # OpenAPI 3.0 specification for REST API
├── spec.md              # Feature specification (already exists)
└── tasks.md             # Phase 2 output (/sp.tasks command - NOT created by /sp.plan)
```

### Source Code (repository root)

```text
# Web Application Structure (frontend + backend separation)

backend/                  # FastAPI backend application
├── app/
│   ├── __init__.py
│   ├── main.py          # FastAPI app instance, CORS, middleware
│   ├── config.py        # Settings (database URL, JWT secret, etc.)
│   ├── database.py      # SQLAlchemy engine, session management
│   ├── models/          # SQLAlchemy ORM models
│   │   ├── __init__.py
│   │   ├── user.py      # User model
│   │   └── task.py      # Task model
│   ├── schemas/         # Pydantic schemas (request/response)
│   │   ├── __init__.py
│   │   ├── user.py      # User DTOs
│   │   ├── task.py      # Task DTOs
│   │   └── auth.py      # Auth DTOs (login, register, token)
│   ├── crud/            # CRUD operations (repository pattern)
│   │   ├── __init__.py
│   │   ├── user.py      # User CRUD
│   │   └── task.py      # Task CRUD
│   ├── api/             # API route handlers
│   │   ├── __init__.py
│   │   ├── deps.py      # Dependencies (get_db, get_current_user)
│   │   ├── auth.py      # Auth endpoints (/register, /login, /logout)
│   │   └── tasks.py     # Task endpoints (/tasks, /tasks/{id})
│   └── utils/           # Utilities
│       ├── __init__.py
│       ├── security.py  # Password hashing, JWT creation/validation
│       └── exceptions.py # Custom exceptions
├── alembic/             # Database migrations
│   ├── versions/        # Migration scripts
│   ├── env.py           # Alembic environment
│   └── alembic.ini      # Alembic configuration
├── tests/               # Backend tests
│   ├── __init__.py
│   ├── conftest.py      # Pytest fixtures
│   ├── test_auth.py     # Auth endpoint tests
│   └── test_tasks.py    # Task endpoint tests
├── requirements.txt     # Python dependencies
├── .env.example         # Environment variable template
└── README.md            # Backend setup instructions

frontend/                # Next.js frontend application
├── app/                 # Next.js 15 app router
│   ├── layout.tsx       # Root layout (global styles, providers)
│   ├── page.tsx         # Landing page (redirect to login or dashboard)
│   ├── login/
│   │   └── page.tsx     # Login page
│   ├── register/
│   │   └── page.tsx     # Registration page
│   └── dashboard/
│       └── page.tsx     # Task dashboard (authenticated route)
├── components/          # React components
│   ├── ui/              # shadcn/ui components
│   │   ├── button.tsx
│   │   ├── input.tsx
│   │   ├── card.tsx
│   │   ├── dialog.tsx
│   │   └── checkbox.tsx
│   ├── auth/
│   │   ├── login-form.tsx
│   │   └── register-form.tsx
│   └── tasks/
│       ├── task-list.tsx
│       ├── task-item.tsx
│       ├── task-create-form.tsx
│       ├── task-edit-dialog.tsx
│       └── task-delete-dialog.tsx
├── lib/                 # Utilities and services
│   ├── api.ts           # API client (axios wrapper with auth)
│   ├── auth.ts          # Auth utilities (login, logout, token management)
│   └── utils.ts         # General utilities (cn, formatters)
├── types/               # TypeScript type definitions
│   ├── task.ts          # Task types
│   └── user.ts          # User types
├── public/              # Static assets
│   └── favicon.ico
├── .env.local.example   # Environment variable template
├── tailwind.config.ts   # Tailwind CSS configuration
├── tsconfig.json        # TypeScript configuration
├── next.config.js       # Next.js configuration
├── package.json         # Node dependencies
└── README.md            # Frontend setup instructions

src/                     # Phase I CLI (preserved, not modified)
└── main.py              # Original console application (frozen)

.env.example             # Root-level environment template
README.md                # Project root documentation
```

**Structure Decision**:

Selected **Option 2: Web application** with separate `frontend/` and `backend/` directories.

**Rationale**:
- Clear separation of concerns between frontend and backend
- Independent deployment (Vercel for frontend, cloud host for backend)
- Different technology stacks (TypeScript vs Python) justify separate directories
- Enables independent scaling and development in future phases
- Prepares for Phase IV microservices decomposition
- Aligns with industry best practices for full-stack applications

**Frontend Structure**: Next.js 15 App Router with TypeScript, organized by feature (auth, tasks) with reusable UI components from shadcn/ui.

**Backend Structure**: FastAPI with layered architecture:
- **Models layer**: SQLAlchemy ORM models (database entities)
- **Schemas layer**: Pydantic schemas (API contracts, validation)
- **CRUD layer**: Data access operations (repository pattern)
- **API layer**: Route handlers (business logic, auth checks)
- **Utils layer**: Cross-cutting concerns (security, exceptions)

## Complexity Tracking

> **Fill ONLY if Constitution Check has violations that must be justified**

**No violations detected**. All architecture decisions comply with Phase II constitution requirements.

## Phase 0: Research & Technology Decisions

**Purpose**: Resolve all technical unknowns and establish technology choices with rationale.

**Research Tasks**:
1. Better Auth vs Custom JWT implementation
2. SQLAlchemy async vs sync for FastAPI
3. Alembic migration best practices
4. Next.js 15 App Router authentication patterns
5. Neon PostgreSQL connection pooling
6. shadcn/ui component library integration
7. FastAPI CORS configuration for Next.js
8. JWT token refresh strategy
9. Frontend state management (React Context vs Zustand)
10. API error handling patterns

**Output**: `research.md` with all decisions documented

**Key Decisions Preview** (to be detailed in research.md):
- **Auth**: Custom JWT (simpler for Phase II, Better Auth reserved for Phase III+)
- **SQLAlchemy**: Async engine (FastAPI best practice, better performance)
- **Migrations**: Alembic with auto-generate from models
- **Next.js Auth**: Middleware-based route protection + Context for state
- **State Management**: React Context (sufficient for Phase II scale)
- **Error Handling**: Standard FastAPI HTTPException + custom error responses

## Phase 1: Design Artifacts

**Purpose**: Generate concrete design documents (data models, API contracts, setup guide).

### 1. Data Model (`data-model.md`)

**Entities**:
1. **User** (from spec Key Entities)
2. **Task** (from spec Key Entities)
3. **Session** (optional - JWT stateless, may not need table)

**Relationships**:
- User 1:N Tasks (one user has many tasks)
- Foreign key: tasks.user_id → users.id

**Schema Design** (to be detailed in data-model.md):
```sql
-- Preview (full schema in data-model.md)
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    email VARCHAR(255) UNIQUE NOT NULL,
    hashed_password VARCHAR(255) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE tasks (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
    title VARCHAR(500) NOT NULL,
    description TEXT DEFAULT '',
    completed BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### 2. API Contracts (`contracts/api-spec.yaml`)

**REST API Endpoints** (OpenAPI 3.0 specification):

**Authentication**:
- `POST /api/auth/register` - Create new user account
- `POST /api/auth/login` - Authenticate and get JWT token
- `POST /api/auth/logout` - Invalidate session (if session table used)

**Tasks** (all require authentication):
- `POST /api/tasks` - Create new task
- `GET /api/tasks` - Get all user's tasks
- `GET /api/tasks/{id}` - Get single task by ID
- `PUT /api/tasks/{id}` - Update task (title, description)
- `PATCH /api/tasks/{id}/complete` - Toggle completion status
- `DELETE /api/tasks/{id}` - Delete task

**Standard Responses**:
- 200 OK - Success with data
- 201 Created - Resource created
- 400 Bad Request - Validation error
- 401 Unauthorized - Not authenticated
- 403 Forbidden - Not authorized (wrong user)
- 404 Not Found - Resource doesn't exist
- 500 Internal Server Error - Server error

### 3. Quickstart Guide (`quickstart.md`)

**Local Development Setup**:
1. Prerequisites (Python 3.13+, Node.js 18+, Neon account)
2. Database setup (create Neon project, get connection string)
3. Backend setup (install dependencies, run migrations, start server)
4. Frontend setup (install dependencies, configure API URL, start dev server)
5. Testing (manual test scenarios from spec)

**Deployment Guide**:
1. Backend deployment (Railway/Render/Fly.io setup)
2. Frontend deployment (Vercel setup, environment variables)
3. Database deployment (Neon configuration, connection pooling)

## Phase 2: Task Generation

**Purpose**: Break down implementation into atomic, testable tasks.

**Organization**: Tasks organized by user story (from spec.md):
- Setup tasks (infrastructure, dependencies)
- Foundational tasks (database, auth, base API)
- US1: User Registration & Authentication (P1)
- US2: Web-Based Task Creation & Viewing (P1)
- US6: User Data Isolation (P1)
- US3: Task Completion Tracking (P2)
- US4: Task Editing & Updating (P2)
- US5: Task Deletion (P3)
- Polish tasks (error handling, loading states, deployment)

**Output**: `tasks.md` (generated by `/sp.tasks` command, not by /sp.plan)

## Implementation Strategy

### MVP Scope (Minimum Viable Product)

**Phase 1 MVP** (P1 user stories only):
1. ✅ User registration and login
2. ✅ Create and view tasks
3. ✅ Data isolation (users see only their tasks)
4. ✅ Task persistence to database

**Deliverable**: Working web app where users can register, log in, create tasks, and view their tasks. All data persists to database. Each user's data is isolated.

**Testing**: Manual testing of P1 scenarios from spec.md

### Incremental Delivery

**Phase 2** (Add P2 features):
- Task completion toggling (US3)
- Task editing (US4)

**Phase 3** (Add P3 features):
- Task deletion (US5)

**Phase 4** (Polish):
- Error handling improvements
- Loading states
- Responsive design validation
- Deployment to production

### Development Order

**Backend First** (API-first approach):
1. Database schema + migrations
2. User model + auth endpoints
3. Task model + CRUD endpoints
4. Manual API testing (Postman/curl)

**Then Frontend**:
1. Auth pages (login, register)
2. Dashboard layout
3. Task list component
4. Task CRUD forms
5. Integration with backend API

**Why Backend First**: Frontend depends on API contracts. Building API first allows early validation of data models and business logic.

## Risk Analysis

### Technical Risks

**Risk 1: Neon PostgreSQL Free Tier Limitations**
- **Impact**: Free tier may have connection limits, storage limits
- **Mitigation**: Use connection pooling, monitor usage, document upgrade path
- **Contingency**: Switch to local PostgreSQL for development, Neon for production only

**Risk 2: CORS Configuration Issues**
- **Impact**: Frontend can't connect to backend during development
- **Mitigation**: Configure CORS early, use environment-specific origins
- **Contingency**: Proxy API requests through Next.js API routes if CORS fails

**Risk 3: JWT Token Management Complexity**
- **Impact**: Token expiration, refresh logic adds complexity
- **Mitigation**: Start with simple access tokens (24hr expiry), add refresh later
- **Contingency**: Use session cookies instead of JWT if token management too complex

**Risk 4: Database Migration Conflicts**
- **Impact**: Alembic migrations fail or create conflicts
- **Mitigation**: Always generate migrations, review before applying, test on separate DB
- **Contingency**: Manual SQL fixes, rollback to last good migration

### Security Risks

**Risk 1: SQL Injection**
- **Mitigation**: Use SQLAlchemy ORM (parameterized queries), never raw SQL
- **Validation**: Penetration testing, input validation on all fields

**Risk 2: Password Storage**
- **Mitigation**: Use bcrypt via passlib, never store plain text
- **Validation**: Code review, security audit of auth module

**Risk 3: XSS Attacks**
- **Mitigation**: React auto-escapes by default, sanitize user input
- **Validation**: Security scanning, manual testing with malicious inputs

**Risk 4: Authorization Bypass**
- **Mitigation**: Verify task ownership in every endpoint, use user_id from JWT
- **Validation**: Integration tests for authorization, multi-user testing

## Testing Strategy

### Backend Testing

**Unit Tests** (pytest):
- CRUD operations (isolated, mocked database)
- Password hashing/verification
- JWT creation/validation
- Input validation (Pydantic schemas)

**Integration Tests** (pytest + TestClient):
- API endpoints end-to-end
- Database transactions (rollback after each test)
- Authentication flow (register → login → access protected route)
- Authorization (user A can't access user B's tasks)

**Manual API Testing**:
- Postman collection for all endpoints
- Test scenarios from spec.md acceptance criteria

### Frontend Testing

**Component Tests** (Jest + React Testing Library):
- Form validation (login, register, task forms)
- Task list rendering
- Component interactions (edit dialog, delete confirmation)

**E2E Tests** (Playwright - optional for Phase II):
- Complete user flows (register → create task → edit → delete)
- Cross-browser testing

**Manual UI Testing**:
- All user stories from spec.md
- Responsive design (mobile, tablet, desktop)
- Browser compatibility (Chrome, Firefox, Safari, Edge)

### Integration Testing

**Full Stack Testing**:
- Frontend + Backend + Database integration
- Authentication flow end-to-end
- Task CRUD operations end-to-end
- Multi-user scenarios (user isolation validation)

## Deployment Strategy

### Development Environment

**Local Setup**:
- Backend: `uvicorn app.main:app --reload` (port 8000)
- Frontend: `npm run dev` (port 3000)
- Database: Neon (cloud, not local PostgreSQL)
- Environment variables: `.env` files (not committed)

### Staging/Production Environment

**Backend Deployment** (Railway/Render/Fly.io):
- Container: Python 3.13 + FastAPI app
- Environment variables: Database URL, JWT secret, CORS origin
- Health check endpoint: `GET /health`
- Auto-deploy on git push to main

**Frontend Deployment** (Vercel):
- Framework: Next.js (auto-detected)
- Environment variables: API URL
- Auto-deploy on git push to main
- Preview deployments on PRs

**Database** (Neon):
- PostgreSQL 14+ serverless
- Connection pooling enabled
- Automatic backups
- Connection string in backend environment variables

**Deployment Checklist**:
1. ✅ Environment variables configured
2. ✅ Database migrations applied
3. ✅ CORS configured for production frontend URL
4. ✅ HTTPS enabled (TLS/SSL)
5. ✅ Health checks passing
6. ✅ Manual smoke test on production

## Performance Optimization

### Backend Optimizations

- **Database Indexing**: Index on `tasks.user_id`, `users.email`
- **Connection Pooling**: SQLAlchemy async engine with pool size limits
- **Query Optimization**: Select only needed fields, avoid N+1 queries
- **Caching**: None in Phase II (add in Phase III if needed)

### Frontend Optimizations

- **Code Splitting**: Next.js automatic code splitting
- **Image Optimization**: Next.js Image component
- **Bundle Size**: Remove unused dependencies, tree-shaking
- **Lazy Loading**: Load task list only when needed

### Database Optimizations

- **Migrations**: Indexed columns for common queries
- **Constraints**: Foreign keys, unique constraints, not null constraints
- **Data Types**: Appropriate sizes (VARCHAR(500) for title, TEXT for description)

## Monitoring & Observability

### Logging

**Backend**:
- FastAPI access logs (requests, responses, errors)
- Application logs (auth events, CRUD operations, errors)
- Log level: INFO for production, DEBUG for development

**Frontend**:
- Client-side error tracking (console.error)
- API request/response logging (development only)

### Metrics

**Backend** (basic):
- Request count per endpoint
- Response time (average, P95)
- Error rate
- Active connections

**Frontend** (basic):
- Page load time
- API call latency
- Error rate

**Database**:
- Connection pool usage
- Query execution time
- Active connections

### Alerting

**Phase II Alerting** (basic):
- Backend health check failures
- Database connection failures
- High error rate (>5%)

**Phase III+**: Advanced monitoring (Prometheus, Grafana, Sentry)

## Documentation Requirements

### Code Documentation

**Backend**:
- Docstrings on all functions (Google style)
- Type hints on all functions and class methods
- Comments for complex business logic only
- README.md with setup instructions

**Frontend**:
- JSDoc comments on utility functions
- TypeScript types for all props and state
- README.md with setup instructions

### API Documentation

**OpenAPI Specification** (`contracts/api-spec.yaml`):
- All endpoints documented
- Request/response schemas
- Error responses
- Authentication requirements

**Auto-Generated Docs**:
- FastAPI Swagger UI (`/docs`)
- FastAPI ReDoc (`/redoc`)

### User Documentation

**Quickstart Guide** (`quickstart.md`):
- Local development setup
- Environment variable configuration
- Database setup
- Running tests
- Deployment instructions

## Migration from Phase I

**Phase I Preservation**:
- `src/main.py` remains unchanged (frozen)
- No code from Phase I deleted
- Phase I can still run: `python src/main.py`

**Code Reuse**:
- Task dataclass → SQLAlchemy Task model (similar structure)
- TaskManager CRUD methods → FastAPI CRUD operations (logic preserved)
- Validation rules → Pydantic schemas (same constraints)

**Data Migration**:
- **None required** (Phase I was in-memory, no data to migrate)
- Users start fresh in Phase II with new accounts

**Conceptual Migration**:
- In-memory dict → PostgreSQL database
- CLI menu → Web UI
- Single user → Multi-user with authentication
- Local execution → Cloud deployment

## Next Steps

**Immediate Actions**:
1. ✅ Plan complete - proceeding to Phase 0 (research.md)
2. Generate research.md with technology decisions
3. Generate data-model.md with database schema
4. Generate contracts/api-spec.yaml with API contracts
5. Generate quickstart.md with setup instructions
6. Update agent context with Phase II technologies
7. Run `/sp.tasks` to generate task breakdown

**Validation Before Proceeding**:
- ✅ Constitution Check passed (all gates green)
- ✅ No complexity violations
- ✅ Project structure defined
- ✅ Technology stack approved (Phase II constitution compliant)

---

**Plan Status**: ✅ **PHASE 1 PLANNING COMPLETE**

**Ready for**: Phase 0 research generation and Phase 1 artifact generation (research.md, data-model.md, contracts/, quickstart.md)
